# Start Here

`Name`: Austin Cook
`NetID`: ac898

For each problem below, you will,

1. List the steps necessary to execute the exploit.
2. An explanation of what the vulnerability was.
3. An explanation of how you would patch the vulnerability.
4. If the challenge had a patch portion, enter the code used to patch the challenge.

--

## Scoreboard

### Steps

1. Press the `F12` key
2. Click on the `Sources` tab
3. Search `/s` as the beginning of sources
4. Note that `/score-board` is a defined constant
5. Add `/score-board` to the url (the full url is `http://localhost:3000/#/score-board`)

---

## DOM XSS

### Exploit steps

1. Click on the search bar at the top of the screen
2. Enter the malicious code `<iframe src="javascript:alert(`xss`)">`
3. Press `Enter` to complete the search, which executes the code

- Note: To exploit this, I also tried several input areas, but found that the vulnerability was located in the search bar.

### Explanation

The vulnerability is that there is no input validation in the search bar. When a user types in an item to search, and presses enter, you can inspect the HTML of the resulting page under the 'Elements' tab of developer tools. It contains the following:

`<span ... id="searchValue"><iframe src="javascript:alert('xss')">...</iframe></span>`

The input was not validaded, and the 'iframe' tax was treated as valid HTML, and because of this, its Javascript was able to be executed.

### Patch

This code uses the Angular web development framework, which I learned that it has security built in by default. This means that it should be validating input automatically, and that something must have been turned of. In the patch section that follows, I reveal where this vulnerability takes place (we are wrongly bypassing Angular security and trusting the text without validation).

### Patch code

```
6	-	      this.searchValue = this.sanitizer.bypassSecurityTrustHtml(queryParam)
6	+	      this.searchValue = queryParam
```

---

## Reflected XSS

### Exploit steps

1. Create an order
2. Click on `Account`, then `Orders and Payment`, then `Order History`
3. Under the order you created, click the truck icon to `Track Order`
4. Notice that the URL at the top contains an id parameter
5. Swap the actual id in the URL for `` <iframe src="javascript:alert(`xss`)"> `` (The full link is: `` http://127.0.0.1:3000/login#/track-result?id=<iframe src="javascript:alert(`xss`)"> ``)
6. Press `Enter` to visit the URL
7. The Reflected XSS attack is complete

### Explanation

This code is vulnerable becasue the value URL parameter `id` on the `track-result` page is placed into the HTML (so that the order nubmer can be placed on the screen) without any validation. Because of this, if code looks like Javascript, it will be executed as Javascript. I attacked the code with this knowledge by adding some malicious code into the URL parameter.

### Patch

There are a few different ways I could go about patching this vulnerability. The easiest is to simply treat the text from the id parameter as text. When setting the HTML value that displays the name of the order that was parsed from the URL parameter, you could use `elementName.textContent`. This sets its text content in such a way that it can't be interpreted as HTML, which is how `elementName.innerHTML` works. Another way to fix this would be to check the parameter against the database, and not display it if it isn't found in the database. This method would be more complex because you have to ensure that improper values are never inserted into the database, so it would be safest to simply go the route of ensuring that the parameter is treated only as text.

### Patch code

Not applicable

---

## Forged Review

### Exploit steps

1. Create a review while logged in with an attacker account
2. Press `Submit` to submit the review
3. Open developer tools with `F12`
4. Click on the `Network` tab
5. Right click on the most recent packet titled `Reviews`
6. Under the `Copy` menu, select `Copy as fetch`
7. Navigate to the `Console` and paste the request
8. Press `Enter`

### Explanation

The issue here is a failure to properly use the authentication. When you look at the coding challenge, you can see that the code grabs the user's information from the request (I believe by using the cookie as authentication), and that information is not used as validation. Therefore, a bad actor can pretend to be another user simply by changing the email that is sent in the request.

### Patch

I would patch the vulnerability by ensuring that the review is only updated if the post id also cooresponds to the user that was authenticated from the request. Since the authentication is trusted, using it would ensure that an attacker couldn't forget update a review. Since the first object in a MongoDB update will filter by all items in the object, adding the email received from authenticating the user will add this ensurance.

### Patch code

```
5	-	      { _id: req.body.id },
5	+	      { _id: req.body.id, author: user.data.email },
```

---

## Login Admin

### Exploit steps

1. Click on `Account` then `Login`
2. For the email field, enter `' OR true;--`
3. For the password field, enter anything (I used `a`)
4. Press `Log in`
5. You are now logged in as `admin@juice-shop.op`

### Explanation

The issue here is that the SQL query inputs are not being sanitized. The `username` and `password` fields accept input which is inserted into the login SQL query to authenticate the user. However, the developer of this website didn't expect others to enter malicious input. The problem with input not being sanitized means that it is treated not only as text for a field, but can be run as SQL code. In this specific injection, the `'` ends the input, and the `OR true` is a statement that will ensure that the query will always evaluate to true. `;` is appended to end the statement, and `--` comments out the rest of the query. Therefore, no matter what, this query evaluates to true, and the attacker gains access to the superuser account.

### Patch

I would patch the vulnerability by using built in functions to ensure that the input can only be treated as text for input, and that none of it can be treated as actual SQL code. In many languages, such as Java, you accomplish this with `prepared statements`. The solution in the code challenge uses the equivalent of a prepared statement using the `Sequelize` module. It allows you to bind a parameter to a variable in the query, and ensures that it will not be executed as SQL code.

### Patch code

```
1	+	import {BasketModel} from "../../../models/basket";
2	+
15	-	    models.sequelize.query(`SELECT * FROM Users WHERE email = '${req.body.email || ''}' AND password = '${security.hash(req.body.password || '')}' AND deletedAt IS NULL`, { model: UserModel, plain: true })
17	+	    models.sequelize.query(`SELECT * FROM Users WHERE email = $1 AND password = $2 AND deletedAt IS NULL`,
18	+	      { bind: [ req.body.email, security.hash(req.body.password) ], model: models.User, plain: true })
```

---

## Admin Section

### Exploit steps

1. Log in as the admin user using the vulnerability above (Login Admin)
2. In the URL field, go to `http://127.0.0.1:3000/#/administration`
3. You are now accessing the admin section of the store

### Explanation

This vulnerability utilizes another privelege escalation vulnerability to gain access to information that the attacker shouldn't have. The problem is that the administration console is accessed through the regular website and there is a privelege escalation vulnerability. The fact that a menu option doesn't even show up for hte admin shows that this is probably not the best place to host the admin console. This is an example of how one vulnerability can lead to other issues.

### Patch

Apart from fixing privelege escalation vulnerabilities that allow unauthorized users to gain access to the admin console, I would also exercise serparation of concerns and move the console to somewhere apart from the user facing website. This could be somewhere local to the server so that requests never need to leave the administrator's network. This would greatly reduce the risk and separate website vulnerabilities from vulnerabilities with the admin console.

### Patch code

```
2	-	  {
2	+	  /* TODO: Externalize admin functions into separate application
3	-	    path: 'administration',
3	+	           that is only accessible inside corporate network.
4	-	    component: AdministrationComponent,
4	+	   */
5	-	    canActivate: [AdminGuard]
5	+	  // {
6	-	  },
6	+	  //   path: 'administration',
7	+	  //   component: AdministrationComponent,
8	+	  //   canActivate: [AdminGuard]
9	+	  // },
```

---

## Admin Registration

### Exploit steps

1. Click on `Account`, then `Log in`, then `Not yet a customer`
2. Register a new user
3. Press `F12` to open developer tools
4. Click on the `Network` tab
5. Select the `Users/` request
6. Click on `Preview` and note the field: `role: "customer"`
7. Right click the request and click `Copy`, then `Copy as fetch`
8. Click on `Console` then paste in the request
9. Change the email to one that hasn't been registered yet
10. Add `\"role\":\"admin\"` as another field at the end of the request body
11. Press `Enter` and note that you have now registered a new user with administrator priveleges

### Explanation

The vulnerability here is that a web request to create a user can simply specify the type of user without any authentication from the administrator. Though most users will create accounts through the user interface, an attacker can see that you can simply create an account through the developer console and specify that their account will have an admin role.

### Patch

To fix this issue, I would ensure that all new accounts are created with the role of `customer`. Currently, it is pulling the role from the request, but specifying customer for all on the backend regaurdless of what the request says would eliminate this issue. If a user needs to have a different role, a separate admin console should be created to be able to grant that kind of access.

### Patch code

```
34	+   context.instance.role = 'customer'
```

---

## API-Only XSS

### Exploit steps

- NOTE: I used Burp Suite to intercept and repeat packets to help me exploit the vulnerability.

1. Open Burp Suite and navigate several parts of the website
2. Ensure that you have authenticated as a user
3. Go to the `Target` menu and look through the API endpoints that have been used
4. Note that `/api/Products` is one and maybe we could try to create a product
5. Click on `Proxy`, then `HTTP History` and right click on any POST to `rest/products/#/reviews` then click `Send to Repeater` (We will use this as the skeleton)
6. Click on the `Repeater` and you will see the item we just sent there
7. Change the endpoint on the top line to `/api/Products`
8. For the content, have a JSON object with a `description`, `author` (the email used to sign up), and a `name`. For the `description`, enter `` <iframe src=\"javascript:alert(`xss`)\"> ``.
9. Press `Send` and you will get a success message back

- NOTE: The last two steps took some iteration for me. I didn't enter a description the first time, but the response showed the valid fields for posting a product. All the products for the website disappeared, so I had to restart Docker. Now that I knew the fields however, I quickly created the product and executed the attack.

### Explanation

There are a couple of huge problems with the code that allow XSS to occur. The first is that the information for products that are posted should be sanatized. I was able to carry out this attack because when I posted a product with Javascript code as the description of a product, it interpreted the Javascript instread of just treating it as text. The second problem that let me carry out this attack is the fact that any user can post a product. I was authenticated with a regular user account (austin.cook.id@outlook.com), and no authorization was performed prior to creating the review.

### Patch

To patch this code, I would first sanatize all field information for creating any product. In the code I was shown to patch, sanitization was completely bypassed. To fix this issue, I simply removed the sanitization bypass code. An additional change that I would make is to perform authentication and authorization before allowing a request to create a product to be fulfilled.

### Patch code

'''
7 - this.trustProductDescription(products)
55 - }
56 -
57 - trustProductDescription (tableData: any[]) {
58 - for (let i = 0; i < tableData.length; i++) {
59 - tableData[i].description = this.sanitizer.bypassSecurityTrustHtml(tableData[i].description)
60 - }
'''
